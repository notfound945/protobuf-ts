// @generated by protobuf-ts 2.11.1 with parameter export_client
// @generated from protobuf file "export-client.proto" (syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message Address
 */
export interface Address {
    /**
     * @generated from protobuf field: string street = 1
     */
    street: string;
    /**
     * @generated from protobuf field: string city = 2
     */
    city: string;
    /**
     * @generated from protobuf field: string state = 3
     */
    state: string;
    /**
     * @generated from protobuf field: string zip = 4
     */
    zip: string;
}
/**
 * @generated from protobuf message SocialInfo
 */
export interface SocialInfo {
    /**
     * @generated from protobuf field: string tel = 1
     */
    tel: string;
    /**
     * @generated from protobuf field: string email = 2
     */
    email: string;
    /**
     * @generated from protobuf field: string website = 3
     */
    website: string;
}
/**
 * @generated from protobuf message PublicPerson
 */
export interface PublicPerson {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: int32 age = 2
     */
    age: number;
    /**
     * @generated from protobuf field: Gender gender = 3
     */
    gender: Gender;
    /**
     * @generated from protobuf field: Education education = 4
     */
    education: Education;
    /**
     * @generated from protobuf field: Career career = 5
     */
    career: Career;
    /**
     * @generated from protobuf field: Address address = 6
     */
    address?: Address;
    /**
     * @generated from protobuf field: SocialInfo socialInfo = 7
     */
    socialInfo?: SocialInfo;
}
/**
 * @generated from protobuf message Req
 */
export interface Req {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
}
/**
 * @generated from protobuf message Resp
 */
export interface Resp {
    /**
     * @generated from protobuf field: string message = 1
     */
    message: string;
}
/**
 * @generated from protobuf message GetAddressInfoReq
 */
export interface GetAddressInfoReq {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
}
/**
 * @generated from protobuf message GetAddressInfoResp
 */
export interface GetAddressInfoResp {
    /**
     * @generated from protobuf field: Address address = 1
     */
    address?: Address;
}
/**
 * @generated from protobuf message GetPersonInfoReq
 */
export interface GetPersonInfoReq {
    /**
     * @generated from protobuf field: string personId = 1
     */
    personId: string;
}
/**
 * @generated from protobuf message GetPersonInfoResp
 */
export interface GetPersonInfoResp {
    /**
     * @generated from protobuf field: PublicPerson person = 1
     */
    person?: PublicPerson;
}
/**
 * @generated from protobuf message GetEmbeddedMessageReq
 */
export interface GetEmbeddedMessageReq {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: GetEmbeddedMessageReq.SizeInfo sizeInfo = 2
     */
    sizeInfo?: GetEmbeddedMessageReq_SizeInfo;
    /**
     * @generated from protobuf field: GetEmbeddedMessageReq.EmbeddedMessageType embeddedMessageType = 3
     */
    embeddedMessageType: GetEmbeddedMessageReq_EmbeddedMessageType;
}
/**
 * @generated from protobuf message GetEmbeddedMessageReq.SizeInfo
 */
export interface GetEmbeddedMessageReq_SizeInfo {
    /**
     * @generated from protobuf field: int32 width = 1
     */
    width: number;
    /**
     * @generated from protobuf field: int32 height = 2
     */
    height: number;
}
/**
 * @generated from protobuf enum GetEmbeddedMessageReq.EmbeddedMessageType
 */
export enum GetEmbeddedMessageReq_EmbeddedMessageType {
    /**
     * @generated from protobuf enum value: UNKNOWN_EMBEDDED_MESSAGE_TYPE = 0;
     */
    UNKNOWN_EMBEDDED_MESSAGE_TYPE = 0,
    /**
     * @generated from protobuf enum value: ADDRESS = 1;
     */
    ADDRESS = 1,
    /**
     * @generated from protobuf enum value: PERSON = 2;
     */
    PERSON = 2,
    /**
     * @generated from protobuf enum value: PRIVATE_PERSON = 3;
     */
    PRIVATE_PERSON = 3
}
/**
 * @generated from protobuf message GetEmbeddedMessageResp
 */
export interface GetEmbeddedMessageResp {
    /**
     * @generated from protobuf field: Address address = 1
     */
    address?: Address;
    /**
     * @generated from protobuf field: GetEmbeddedMessageResp.RespCode respCode = 2
     */
    respCode: GetEmbeddedMessageResp_RespCode;
    /**
     * @generated from protobuf field: GetEmbeddedMessageResp.ErrorInfo errorInfo = 3
     */
    errorInfo?: GetEmbeddedMessageResp_ErrorInfo;
}
/**
 * @generated from protobuf message GetEmbeddedMessageResp.ErrorInfo
 */
export interface GetEmbeddedMessageResp_ErrorInfo {
    /**
     * @generated from protobuf field: string errorMessage = 1
     */
    errorMessage: string;
    /**
     * @generated from protobuf field: uint32 errorCode = 2
     */
    errorCode: number;
}
/**
 * @generated from protobuf enum GetEmbeddedMessageResp.RespCode
 */
export enum GetEmbeddedMessageResp_RespCode {
    /**
     * @generated from protobuf enum value: UNKNOWN_RESP_CODE = 0;
     */
    UNKNOWN_RESP_CODE = 0,
    /**
     * @generated from protobuf enum value: SUCCESS = 1;
     */
    SUCCESS = 1,
    /**
     * @generated from protobuf enum value: ERROR = 2;
     */
    ERROR = 2
}
/**
 * @generated from protobuf enum Gender
 */
export enum Gender {
    /**
     * @generated from protobuf enum value: UNKNOWN_GENDER = 0;
     */
    UNKNOWN_GENDER = 0,
    /**
     * @generated from protobuf enum value: MALE = 1;
     */
    MALE = 1,
    /**
     * @generated from protobuf enum value: FEMALE = 2;
     */
    FEMALE = 2
}
/**
 * @generated from protobuf enum Education
 */
export enum Education {
    /**
     * @generated from protobuf enum value: UNKNOWN_EDUCATION = 0;
     */
    UNKNOWN_EDUCATION = 0,
    /**
     * @generated from protobuf enum value: PRIMARY = 1;
     */
    PRIMARY = 1,
    /**
     * @generated from protobuf enum value: SECONDARY = 2;
     */
    SECONDARY = 2,
    /**
     * @generated from protobuf enum value: TERTIARY = 3;
     */
    TERTIARY = 3
}
/**
 * @generated from protobuf enum Career
 */
export enum Career {
    /**
     * @generated from protobuf enum value: UNKNOWN_CAREER = 0;
     */
    UNKNOWN_CAREER = 0,
    /**
     * @generated from protobuf enum value: STUDENT = 1;
     */
    STUDENT = 1,
    /**
     * @generated from protobuf enum value: EMPLOYED = 2;
     */
    EMPLOYED = 2,
    /**
     * @generated from protobuf enum value: UNEMPLOYED = 3;
     */
    UNEMPLOYED = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class Address$Type extends MessageType<Address> {
    constructor() {
        super("Address", [
            { no: 1, name: "street", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "city", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "zip", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Address>): Address {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.street = "";
        message.city = "";
        message.state = "";
        message.zip = "";
        if (value !== undefined)
            reflectionMergePartial<Address>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Address): Address {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string street */ 1:
                    message.street = reader.string();
                    break;
                case /* string city */ 2:
                    message.city = reader.string();
                    break;
                case /* string state */ 3:
                    message.state = reader.string();
                    break;
                case /* string zip */ 4:
                    message.zip = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Address, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string street = 1; */
        if (message.street !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.street);
        /* string city = 2; */
        if (message.city !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.city);
        /* string state = 3; */
        if (message.state !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.state);
        /* string zip = 4; */
        if (message.zip !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.zip);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Address
 */
export const Address = new Address$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SocialInfo$Type extends MessageType<SocialInfo> {
    constructor() {
        super("SocialInfo", [
            { no: 1, name: "tel", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "website", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SocialInfo>): SocialInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tel = "";
        message.email = "";
        message.website = "";
        if (value !== undefined)
            reflectionMergePartial<SocialInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SocialInfo): SocialInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tel */ 1:
                    message.tel = reader.string();
                    break;
                case /* string email */ 2:
                    message.email = reader.string();
                    break;
                case /* string website */ 3:
                    message.website = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SocialInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tel = 1; */
        if (message.tel !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tel);
        /* string email = 2; */
        if (message.email !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.email);
        /* string website = 3; */
        if (message.website !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.website);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SocialInfo
 */
export const SocialInfo = new SocialInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublicPerson$Type extends MessageType<PublicPerson> {
    constructor() {
        super("PublicPerson", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "age", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "gender", kind: "enum", T: () => ["Gender", Gender] },
            { no: 4, name: "education", kind: "enum", T: () => ["Education", Education] },
            { no: 5, name: "career", kind: "enum", T: () => ["Career", Career] },
            { no: 6, name: "address", kind: "message", T: () => Address },
            { no: 7, name: "socialInfo", kind: "message", T: () => SocialInfo }
        ]);
    }
    create(value?: PartialMessage<PublicPerson>): PublicPerson {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.age = 0;
        message.gender = 0;
        message.education = 0;
        message.career = 0;
        if (value !== undefined)
            reflectionMergePartial<PublicPerson>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublicPerson): PublicPerson {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* int32 age */ 2:
                    message.age = reader.int32();
                    break;
                case /* Gender gender */ 3:
                    message.gender = reader.int32();
                    break;
                case /* Education education */ 4:
                    message.education = reader.int32();
                    break;
                case /* Career career */ 5:
                    message.career = reader.int32();
                    break;
                case /* Address address */ 6:
                    message.address = Address.internalBinaryRead(reader, reader.uint32(), options, message.address);
                    break;
                case /* SocialInfo socialInfo */ 7:
                    message.socialInfo = SocialInfo.internalBinaryRead(reader, reader.uint32(), options, message.socialInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublicPerson, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* int32 age = 2; */
        if (message.age !== 0)
            writer.tag(2, WireType.Varint).int32(message.age);
        /* Gender gender = 3; */
        if (message.gender !== 0)
            writer.tag(3, WireType.Varint).int32(message.gender);
        /* Education education = 4; */
        if (message.education !== 0)
            writer.tag(4, WireType.Varint).int32(message.education);
        /* Career career = 5; */
        if (message.career !== 0)
            writer.tag(5, WireType.Varint).int32(message.career);
        /* Address address = 6; */
        if (message.address)
            Address.internalBinaryWrite(message.address, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* SocialInfo socialInfo = 7; */
        if (message.socialInfo)
            SocialInfo.internalBinaryWrite(message.socialInfo, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PublicPerson
 */
export const PublicPerson = new PublicPerson$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Req$Type extends MessageType<Req> {
    constructor() {
        super("Req", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Req>): Req {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<Req>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Req): Req {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Req, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Req
 */
export const Req = new Req$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Resp$Type extends MessageType<Resp> {
    constructor() {
        super("Resp", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Resp>): Resp {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<Resp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Resp): Resp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Resp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Resp
 */
export const Resp = new Resp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAddressInfoReq$Type extends MessageType<GetAddressInfoReq> {
    constructor() {
        super("GetAddressInfoReq", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetAddressInfoReq>): GetAddressInfoReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<GetAddressInfoReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAddressInfoReq): GetAddressInfoReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAddressInfoReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetAddressInfoReq
 */
export const GetAddressInfoReq = new GetAddressInfoReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAddressInfoResp$Type extends MessageType<GetAddressInfoResp> {
    constructor() {
        super("GetAddressInfoResp", [
            { no: 1, name: "address", kind: "message", T: () => Address }
        ]);
    }
    create(value?: PartialMessage<GetAddressInfoResp>): GetAddressInfoResp {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetAddressInfoResp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAddressInfoResp): GetAddressInfoResp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Address address */ 1:
                    message.address = Address.internalBinaryRead(reader, reader.uint32(), options, message.address);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAddressInfoResp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Address address = 1; */
        if (message.address)
            Address.internalBinaryWrite(message.address, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetAddressInfoResp
 */
export const GetAddressInfoResp = new GetAddressInfoResp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPersonInfoReq$Type extends MessageType<GetPersonInfoReq> {
    constructor() {
        super("GetPersonInfoReq", [
            { no: 1, name: "personId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetPersonInfoReq>): GetPersonInfoReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.personId = "";
        if (value !== undefined)
            reflectionMergePartial<GetPersonInfoReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPersonInfoReq): GetPersonInfoReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string personId */ 1:
                    message.personId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPersonInfoReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string personId = 1; */
        if (message.personId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.personId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetPersonInfoReq
 */
export const GetPersonInfoReq = new GetPersonInfoReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPersonInfoResp$Type extends MessageType<GetPersonInfoResp> {
    constructor() {
        super("GetPersonInfoResp", [
            { no: 1, name: "person", kind: "message", T: () => PublicPerson }
        ]);
    }
    create(value?: PartialMessage<GetPersonInfoResp>): GetPersonInfoResp {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetPersonInfoResp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPersonInfoResp): GetPersonInfoResp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* PublicPerson person */ 1:
                    message.person = PublicPerson.internalBinaryRead(reader, reader.uint32(), options, message.person);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPersonInfoResp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* PublicPerson person = 1; */
        if (message.person)
            PublicPerson.internalBinaryWrite(message.person, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetPersonInfoResp
 */
export const GetPersonInfoResp = new GetPersonInfoResp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEmbeddedMessageReq$Type extends MessageType<GetEmbeddedMessageReq> {
    constructor() {
        super("GetEmbeddedMessageReq", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sizeInfo", kind: "message", T: () => GetEmbeddedMessageReq_SizeInfo },
            { no: 3, name: "embeddedMessageType", kind: "enum", T: () => ["GetEmbeddedMessageReq.EmbeddedMessageType", GetEmbeddedMessageReq_EmbeddedMessageType] }
        ]);
    }
    create(value?: PartialMessage<GetEmbeddedMessageReq>): GetEmbeddedMessageReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.embeddedMessageType = 0;
        if (value !== undefined)
            reflectionMergePartial<GetEmbeddedMessageReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEmbeddedMessageReq): GetEmbeddedMessageReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* GetEmbeddedMessageReq.SizeInfo sizeInfo */ 2:
                    message.sizeInfo = GetEmbeddedMessageReq_SizeInfo.internalBinaryRead(reader, reader.uint32(), options, message.sizeInfo);
                    break;
                case /* GetEmbeddedMessageReq.EmbeddedMessageType embeddedMessageType */ 3:
                    message.embeddedMessageType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEmbeddedMessageReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* GetEmbeddedMessageReq.SizeInfo sizeInfo = 2; */
        if (message.sizeInfo)
            GetEmbeddedMessageReq_SizeInfo.internalBinaryWrite(message.sizeInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* GetEmbeddedMessageReq.EmbeddedMessageType embeddedMessageType = 3; */
        if (message.embeddedMessageType !== 0)
            writer.tag(3, WireType.Varint).int32(message.embeddedMessageType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetEmbeddedMessageReq
 */
export const GetEmbeddedMessageReq = new GetEmbeddedMessageReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEmbeddedMessageReq_SizeInfo$Type extends MessageType<GetEmbeddedMessageReq_SizeInfo> {
    constructor() {
        super("GetEmbeddedMessageReq.SizeInfo", [
            { no: 1, name: "width", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "height", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetEmbeddedMessageReq_SizeInfo>): GetEmbeddedMessageReq_SizeInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.width = 0;
        message.height = 0;
        if (value !== undefined)
            reflectionMergePartial<GetEmbeddedMessageReq_SizeInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEmbeddedMessageReq_SizeInfo): GetEmbeddedMessageReq_SizeInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 width */ 1:
                    message.width = reader.int32();
                    break;
                case /* int32 height */ 2:
                    message.height = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEmbeddedMessageReq_SizeInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 width = 1; */
        if (message.width !== 0)
            writer.tag(1, WireType.Varint).int32(message.width);
        /* int32 height = 2; */
        if (message.height !== 0)
            writer.tag(2, WireType.Varint).int32(message.height);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetEmbeddedMessageReq.SizeInfo
 */
export const GetEmbeddedMessageReq_SizeInfo = new GetEmbeddedMessageReq_SizeInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEmbeddedMessageResp$Type extends MessageType<GetEmbeddedMessageResp> {
    constructor() {
        super("GetEmbeddedMessageResp", [
            { no: 1, name: "address", kind: "message", T: () => Address },
            { no: 2, name: "respCode", kind: "enum", T: () => ["GetEmbeddedMessageResp.RespCode", GetEmbeddedMessageResp_RespCode] },
            { no: 3, name: "errorInfo", kind: "message", T: () => GetEmbeddedMessageResp_ErrorInfo }
        ]);
    }
    create(value?: PartialMessage<GetEmbeddedMessageResp>): GetEmbeddedMessageResp {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.respCode = 0;
        if (value !== undefined)
            reflectionMergePartial<GetEmbeddedMessageResp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEmbeddedMessageResp): GetEmbeddedMessageResp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Address address */ 1:
                    message.address = Address.internalBinaryRead(reader, reader.uint32(), options, message.address);
                    break;
                case /* GetEmbeddedMessageResp.RespCode respCode */ 2:
                    message.respCode = reader.int32();
                    break;
                case /* GetEmbeddedMessageResp.ErrorInfo errorInfo */ 3:
                    message.errorInfo = GetEmbeddedMessageResp_ErrorInfo.internalBinaryRead(reader, reader.uint32(), options, message.errorInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEmbeddedMessageResp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Address address = 1; */
        if (message.address)
            Address.internalBinaryWrite(message.address, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* GetEmbeddedMessageResp.RespCode respCode = 2; */
        if (message.respCode !== 0)
            writer.tag(2, WireType.Varint).int32(message.respCode);
        /* GetEmbeddedMessageResp.ErrorInfo errorInfo = 3; */
        if (message.errorInfo)
            GetEmbeddedMessageResp_ErrorInfo.internalBinaryWrite(message.errorInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetEmbeddedMessageResp
 */
export const GetEmbeddedMessageResp = new GetEmbeddedMessageResp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEmbeddedMessageResp_ErrorInfo$Type extends MessageType<GetEmbeddedMessageResp_ErrorInfo> {
    constructor() {
        super("GetEmbeddedMessageResp.ErrorInfo", [
            { no: 1, name: "errorMessage", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "errorCode", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetEmbeddedMessageResp_ErrorInfo>): GetEmbeddedMessageResp_ErrorInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.errorMessage = "";
        message.errorCode = 0;
        if (value !== undefined)
            reflectionMergePartial<GetEmbeddedMessageResp_ErrorInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEmbeddedMessageResp_ErrorInfo): GetEmbeddedMessageResp_ErrorInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string errorMessage */ 1:
                    message.errorMessage = reader.string();
                    break;
                case /* uint32 errorCode */ 2:
                    message.errorCode = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEmbeddedMessageResp_ErrorInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string errorMessage = 1; */
        if (message.errorMessage !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.errorMessage);
        /* uint32 errorCode = 2; */
        if (message.errorCode !== 0)
            writer.tag(2, WireType.Varint).uint32(message.errorCode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetEmbeddedMessageResp.ErrorInfo
 */
export const GetEmbeddedMessageResp_ErrorInfo = new GetEmbeddedMessageResp_ErrorInfo$Type();
/**
 * @generated ServiceType for protobuf service ExportClientService
 */
export const ExportClientService = new ServiceType("ExportClientService", [
    { name: "EmptyOptionMethod", options: {}, I: Req, O: Resp },
    { name: "MethodWithExportClient1", options: { "blocker.exportclient": 1 }, I: Req, O: Resp },
    { name: "GetAddressInfo", options: { "blocker.exportclient": 1 }, I: GetAddressInfoReq, O: GetAddressInfoResp },
    { name: "GetPersonInfo", options: { "blocker.exportclient": 1 }, I: GetPersonInfoReq, O: GetPersonInfoResp },
    { name: "GetEmbeddedMessage", options: { "blocker.exportclient": 1 }, I: GetEmbeddedMessageReq, O: GetEmbeddedMessageResp }
]);
